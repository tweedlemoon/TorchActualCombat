# 知识点记录

## Python相关

### 静态方法

位置：my_dataset.py类VOCSegmentation

```python
@staticmethod 
def collate_fn(batch):
    ...
```

静态方法和类方法@classmethod  

两者的共同点就是不需要实例化  

- @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
- @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。

```python
class A(object):
    param = 0

    def __init__(self):
        self.param = 1

    def foo(self, x):
        print("executing foo(%s,%s)" % (self, x))

    @classmethod
    def class_foo(cls, x):
        print("executing class_foo(%s,%s,%s)" % (cls.static_foo(x), x, cls.param))

    @staticmethod
    def static_foo(x):
        print("executing static_foo(%s)" % x)
```

```
$ A.class_foo(1)
executing static_foo(1)
executing class_foo(None,1,0)

$ A.static_foo(1)
executing static_foo(1)
```

不用创建实例就可以调用的两个函数，静态那个跟类连关系都没有，而带cls的会带类里最基础的信息，但是不会执行\_\_init\_\_函数

另外，类中\_代表私有，\_\_代表子类不能访问的高级私有

### assert断言

```python
assert expression
```

等价于

```python
if not expression:
    raise AssertionError
```

翻译：如果不这样就报错的意思，assert用法就是放在程序中判定一个东西是否合法。

同理

```python
assert expression [, arguments]
```

等价于

````python
if not expression:
    raise AssertionError(arguments)
````

举例
```python
import sys
assert ('linux' in sys.platform), "该代码只能在 Linux 下执行"
```

###  元组，列表颠倒

```python
a=(7,9,10,11)
a[::-1]
b=[3,4,5,6]
b[::-1]

print(a)
(11,10,9,7)
print(b)
[6,5,4,3]
```

### str.strip()

对str类型使用，作用是用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。

```python
str = "00000003210Runoob01230000000"; 
print str.strip( '0' );  # 去除首尾字符 0
str2 = "   Runoob      ";   # 去除首尾空格
print str2.strip();

3210Runoob0123
Runoob
```

### str.format()

用于替换掉str中的{}从而对字符串进行定点特殊插入。

### \_\_call\_\_()方法

类里经常有\_\_call\_\_()方法，此类方法是当直接调用类的时候起作用，例如

```python
class A(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __call__(self):
        print('my name is %s' % self.name)
        print('my age is %s' % self.age)


if __name__ == '__main__':
    a = A('jack', 26)
    a()# 这里直接调用类了


my name is jack
my age is 26
```

### list.extend

列表拼元素：append；列表拼列表：extend

```python
aList = [123, 'xyz', 'zara', 'abc', 123];
bList = [2009, 'manni'];
aList.extend(bList)

print "Extended List : ", aList ;

Extended List :  [123, 'xyz', 'zara', 'abc', 123, 2009, 'manni']
```

### random.radom()

```python
import random

random.random()
```

产生一个0-1的随机数

```python
print( random.randint(1,10) )        # 产生 1 到 10 的一个整数型随机数  
print( random.random() )             # 产生 0 到 1 之间的随机浮点数
print( random.uniform(1.1,5.4) )     # 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数
print( random.choice('tomorrow') )   # 从序列中随机选取一个元素
print( random.randrange(1,100,2) )   # 生成从1到100的间隔为2的随机整数

a=[1,3,5,6,7]                # 将序列a中的元素顺序打乱
random.shuffle(a)
```

### zip()

```python
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 返回一个对象
>>> zipped
<zip object at 0x103abc288>
>>> list(zipped)  # list() 转换为列表
[(1, 4), (2, 5), (3, 6)]
>>> list(zip(a,c))              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]

>>> a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
>>> list(a1)
[1, 2, 3]
>>> list(a2)
[4, 5, 6]
>>>
```

### time方法

time.time()返回自1970年1月1日0点到现在的浮点秒数，故type出来是float

注意在中国区是1970年1月1日8点

```python
import time

print "time.time(): %f " %  time.time()
time.time(): 1234892919.655932

print time.localtime( time.time() )
(2009, 2, 17, 10, 48, 39, 1, 48, 0)

print time.asctime( time.localtime(time.time()) )
# 此语句等价于time.ctime(time.time())
Tue Feb 17 10:48:39 2009

# 单独提取
>>> time = time.localtime(time.time())
>>> print time
time.struct_time(tm_year=2018, tm_mon=2, tm_mday=8, tm_hour=13, tm_min=37, tm_sec=31, tm_wday=3, tm_yday=39, tm_isdst=0)
>>> print time.tm_year
2018
>>> print time.tm_mon
2
```




## Pytorch相关

### torch.utils.data.Dataset类和torch.utils.data.DataLoader方法的组合拳

DataLoader可以读取pytorch官方封装的数据集，但是如果想读取自己的数据，则必须将自己的数据按照pytorch规定的Dataset类封好。

​	

### 关于mean=(0.485, 0.456, 0.406), std=(0.229, 0.224, 0.225)

这是因为使用了使用ImageNet的均值和标准差。  

使用Imagenet的均值和标准差是一种常见的做法。它们是根据数百万张图像计算得出的。如果要在自己的数据集上从头开始训练，则可以计算新的均值和标准差。否则，建议使用ImageNet预设模型及其平均值和标准差。

具体说法见https://www.cnblogs.com/devilmaycry812839668/p/15590860.html



### 学习率动态变化参数torch.optim.lr_scheduler

https://zhuanlan.zhihu.com/p/380795956

其中包含以下几种

1.torch.optim.lr_scheduler.StepLR

2.torch.optim.lr_scheduler.MultiStepLR

3.torch.optim.lr_scheduler.ExponentialLR

4.torch.optim.lr_scheduler.CosineAnnealingLR

5.torch.optim.lr_scheduler.ReduceLROnPlateau

6.torch.optim.lr_scheduler.LambdaLR

