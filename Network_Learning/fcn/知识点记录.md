# 知识点记录

## Python相关

### 静态方法

位置：my_dataset.py类VOCSegmentation

```python
@staticmethod 
def collate_fn(batch):
    ...
```

静态方法和类方法@classmethod  

两者的共同点就是不需要实例化  

- @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
- @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。

```python
class A(object):
    param = 0

    def __init__(self):
        self.param = 1

    def foo(self, x):
        print("executing foo(%s,%s)" % (self, x))

    @classmethod
    def class_foo(cls, x):
        print("executing class_foo(%s,%s,%s)" % (cls.static_foo(x), x, cls.param))

    @staticmethod
    def static_foo(x):
        print("executing static_foo(%s)" % x)
```

```
$ A.class_foo(1)
executing static_foo(1)
executing class_foo(None,1,0)

$ A.static_foo(1)
executing static_foo(1)
```

不用创建实例就可以调用的两个函数，静态那个跟类连关系都没有，而带cls的会带类里最基础的信息，但是不会执行\_\_init\_\_函数

另外，类中\_代表私有，\_\_代表子类不能访问的高级私有

### assert断言

```python
assert expression
```

等价于

```python
if not expression:
    raise AssertionError
```

翻译：如果不这样就报错的意思，assert用法就是放在程序中判定一个东西是否合法。

同理

```python
assert expression [, arguments]
```

等价于

````python
if not expression:
    raise AssertionError(arguments)
````

举例
```python
import sys
assert ('linux' in sys.platform), "该代码只能在 Linux 下执行"
```

###  元组，列表颠倒

```python
a=(7,9,10,11)
a[::-1]
b=[3,4,5,6]
b[::-1]

print(a)
(11,10,9,7)
print(b)
[6,5,4,3]
```

### str.strip()

对str类型使用，作用是用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。

```python
str = "00000003210Runoob01230000000"; 
print str.strip( '0' );  # 去除首尾字符 0
str2 = "   Runoob      ";   # 去除首尾空格
print str2.strip();

3210Runoob0123
Runoob
```

### \_\_call\_\_()方法

类里经常有\_\_call\_\_()方法，此类方法是当直接调用类的时候起作用，例如

```python
class A(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __call__(self):
        print('my name is %s' % self.name)
        print('my age is %s' % self.age)


if __name__ == '__main__':
    a = A('jack', 26)
    a()# 这里直接调用类了


my name is jack
my age is 26
```

### list.extend

列表拼元素：append；列表拼列表：extend

```python
aList = [123, 'xyz', 'zara', 'abc', 123];
bList = [2009, 'manni'];
aList.extend(bList)

print "Extended List : ", aList ;

Extended List :  [123, 'xyz', 'zara', 'abc', 123, 2009, 'manni']
```

### random.radom()

```python
import random

random.random()
```

产生一个0-1的随机数

```python
print( random.randint(1,10) )        # 产生 1 到 10 的一个整数型随机数  
print( random.random() )             # 产生 0 到 1 之间的随机浮点数
print( random.uniform(1.1,5.4) )     # 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数
print( random.choice('tomorrow') )   # 从序列中随机选取一个元素
print( random.randrange(1,100,2) )   # 生成从1到100的间隔为2的随机整数

a=[1,3,5,6,7]                # 将序列a中的元素顺序打乱
random.shuffle(a)
```




## Pytorch相关

### torch.utils.data.Dataset类和torch.utils.data.DataLoader方法的组合拳

DataLoader可以读取pytorch官方封装的数据集，但是如果想读取自己的数据，则必须将自己的数据按照pytorch规定的Dataset类封好。

​	

