# 知识点记录

## Python相关

### 静态方法

位置：my_dataset.py类VOCSegmentation

```python
@staticmethod 
def collate_fn(batch):
    ...
```

静态方法和类方法@classmethod  

两者的共同点就是不需要实例化  

- @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
- @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。

```python
class A(object):
    param = 0

    def __init__(self):
        self.param = 1

    def foo(self, x):
        print("executing foo(%s,%s)" % (self, x))

    @classmethod
    def class_foo(cls, x):
        print("executing class_foo(%s,%s,%s)" % (cls.static_foo(x), x, cls.param))

    @staticmethod
    def static_foo(x):
        print("executing static_foo(%s)" % x)
```

```
$ A.class_foo(1)
executing static_foo(1)
executing class_foo(None,1,0)

$ A.static_foo(1)
executing static_foo(1)
```

不用创建实例就可以调用的两个函数，静态那个跟类连关系都没有，而带cls的会带类里最基础的信息，但是不会执行\_\_init\_\_函数

另外，类中\_代表私有，\_\_代表子类不能访问的高级私有

### assert断言

```python
assert expression
```

等价于

```python
if not expression:
    raise AssertionError
```

翻译：如果不这样就报错的意思，assert用法就是放在程序中判定一个东西是否合法。

同理

```python
assert expression [, arguments]
```

等价于

````python
if not expression:
    raise AssertionError(arguments)
````

举例
```python
import sys
assert ('linux' in sys.platform), "该代码只能在 Linux 下执行"
```

###  元组，列表颠倒

```python
a=(7,9,10,11)
a[::-1]
b=[3,4,5,6]
b[::-1]

print(a)
(11,10,9,7)
print(b)
[6,5,4,3]
```



## Pytorch相关

### torch.utils.data.Dataset类和torch.utils.data.DataLoader方法的组合拳

DataLoader可以读取pytorch官方封装的数据集，但是如果想读取自己的数据，则必须将自己的数据按照pytorch规定的Dataset类封好。



