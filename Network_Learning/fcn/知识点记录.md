# 知识点记录

## Python相关

### 静态方法

位置：my_dataset.py类VOCSegmentation

```python
@staticmethod 
def collate_fn(batch):
    ...
```

静态方法和类方法@classmethod  

两者的共同点就是不需要实例化  

- @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
- @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。

```python
class A(object):
    param = 0

    def __init__(self):
        self.param = 1

    def foo(self, x):
        print("executing foo(%s,%s)" % (self, x))

    @classmethod
    def class_foo(cls, x):
        print("executing class_foo(%s,%s,%s)" % (cls.static_foo(x), x, cls.param))

    @staticmethod
    def static_foo(x):
        print("executing static_foo(%s)" % x)
```

```
$ A.class_foo(1)
executing static_foo(1)
executing class_foo(None,1,0)

$ A.static_foo(1)
executing static_foo(1)
```

不用创建实例就可以调用的两个函数，静态那个跟类连关系都没有，而带cls的会带类里最基础的信息，但是不会执行\_\_init\_\_函数

另外，类中\_代表私有，\_\_代表子类不能访问的高级私有



## Pytorch相关

### torch.utils.data.DataLoader

